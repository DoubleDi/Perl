ООП
Пакеты + данные = bless - получиля обьект
только hashrefы использовать

имя обьекта->функция/аргумент
1 аргумент - $self указатель на обьект;(лучше не менять имя)
это не пакет а уже обьект!!!
есть методы и атрибуты
нет new, он только самописный

можно явно брать методы ровно из пакета а не из классса
по строке с названием тоже можно звать методы, также и имя метода  - стрикт не ругается

класс все еще пакет только стрелочка позволяет оживать

My::Class->new(1, 2, 3) == new My::Class(1, 2, 3) #ужас, никогда так не делать

can - может ли быть исполнен метод в обьекте
не только true и false, но если true то возвращает метод из нужного родителя

filehandle - тоже обьект
$fh
STDOUT, STDIN, STDERR -тоже обьекты
use == ->import
no == ->unimport
use 10.01 == ->VERSION(10.01)

exporter тоже може наследовать

Примеры
Базы данных DBI
$dbh == databasehandler
от него наследуются 

XML
XML::LibXML->load_xml 

File::Spec
File::Spec->catfile('a', 'b', 'c'); #a/b/c;

JSON
JSON->new->utf8->decode('...'); #возвращает всегда один и тот же обьект т е просто настраиваем JSON

В МОДУЛЯХ ТОЛЬКО ОБЬЕКТНЫЙ ИНТЕРФЕЙС - НЕ EXPORTER

Наследование
push (@ISA, 'Dog', 'Cat') # кладем имена родителей;
use base qw(Dog Cat);# старый
use parent qw(Dog Cat); # самый лучший метод
UNIVERSIAL - суперродитель
isa() - проверяет на наследование

SUPER указывает на родителя, из которого если что позовется метод.
->SUPER::foo(); #зовет метод из родителя method название метода

Method resolution order
cтремный порядок слева направо
mro
есть решение c3 не пойдет вверх пока не обойдет всех дочерних
->next::method($param); # cледующий метод method название функции;
next круче SUPER

проверяем на обьект:
ref #Обьект хэш массив и пр 
blessed #Обьект или undef

AUTOLOAD
позовется - если нету у меня и у моих родителей
can не узнает что мы переопределили AUTOLOAD
поэтому надо в can тоже изменять все !!!
UNIVERSAL::AUTOLOAD { } - по цепочке

DESTROY
вызовет деструктор
die - не упадет
local - всем переменным иначе все переменные неожиданно изменятся
AUTOLOAD - обьявить пустой дестрой
${^GLOBAL_PHASE} eq 'DESTRUCT' - exit

Class::Accessor чтобы не писать setget самому
mk_accessors(qw(name role salary)); set_
но быстрее XS::Accessors !!!

Moose-like

Moose - это круто
has password #5 параметров - добавить аттрибут
has #cоздает методыыыыыыы
->new уже есть
наследование == extends

BUILD { #в любом случае
}

default хук #если не будет подан параметр снаружи
   lasy => 1

builder как default только можно переопределять
_method - приватный#договоренность
method - публичный#

    lasy_build => 1
has - много аттрибутов
цепочки - можно определять прям цепочки и инициализировать

Миксины - логику в класс насыпать
with

use Moose::Role;
use Some::Digest;
и обьявляем

Делегирование 
перебрасываем на другие названия методов

ДЗ

Итератор 4 типа
либо с музом либо без него




