Общение с внешним миром
Работа с файлом

как в си, но не дискрипторы а  фаловые манипуляторы
STDIN STDOUT STDERR FILE_HANDLE - oldschool
<> == <STDIN>
my $fh - newschool
open or die т к просто так open не бросает исключения 
ошибка в $!
close
< +< > +> >>
r r+ w w+ a
можно указать кодировку при открытии (читает на байтиками а символами)
русские буквы - обязателньо ставить флаг!!!
Чтение
<>
$line = <$fh> #cтрочка
@lines = <$handle> #все строчки в массив
Запись
print $var == print STDOUT $var
print $fh $var
print STDERR $var

__DATA_ _ ниже можно писать что угодно - буддет воспринятко как шаблон

можно в ручную указать способ чтения: binmode, syswrite, sysread, read, eof;
как в си: syswrite/sysread - не буферезированные
read - бууферезированые

md5

seek - на позицию  type == 0  1  2 START FIN CURR
len == на символы
tell - скажи позицию - возвр колиество байт
ВАЖНО - RAW - чтобы по строкам гонять

проверки на чтение/запись/исполнение
-r -w -x -e -z -s
-f -d -l -S -p
 возвращают true или false
есть и другие фишечки...

Директории
mkdir, rmdir, chdir - как в Си
относительные пути лучше
make_path - крутой mkdir
opendir, closedir, readdir, seekdir, telldir

Perl io - надстройка над fd
:perlio
экономия - не надо весь блок сразу читать
:crlf  - преобразует переводы строки
:utf8 - преобр
:encoding - перекодировка
:bytes - байты
:raw - бинарники
:pop - убирает верхний слой
:via интерфейс для создания 

дз perl::via - все есть на cpan

Процессы
backticks - можно прям запскать все что может сделать ОС
system() - выполнит и проверит но результат не вернет
open(,'-|') - pipe
pipe - связка процессов однонаправленная 
fork - создает копию процесса (copy on write) не связывает процессы - возвращает pid если master process
exec - замена процесса другим

сигналы
$SIG{CHLD} - дергается когда процесс завершается;
WNOHANG - не блокируем мастера
$SIG{ALRM} - alarm();
$SIG{INT} = 'IGNORE' // писать субрутину чтобы вызывать;
можно писать где угодно
Дополнительные модули
Open3 Run3 Handle #блокирующие
именованные каналы named.pipe

сокеты
как в СИ
IO::Socket::INET
удобная обертка над Socket
socket - можно и писать и читать

клиент и сервер в презентации
autoflush(1) -важно
обслуживать много клиентов - через fork
getpeername - возвращает структуру клиента

json(строка) -> perl структура

сериализация
perl типы -> bite и наоборот
	pack - perl в данные
unpack - данные в perl
pack TEMPLATE, LIST - есть всякие шаблоны по свертке строк
TEMPLATE - протоколы чтобы запихивать и выпихивать 

JSON - сериализатор - 1 валидная строка
json_encode decode
CBOR - серализатор (бинарный) - много cbor в одном потоке
decode_cbor encode cbor
MSGPACK - 
Storable - сериализует в файлы бинарные данные
store 
freeze thaw // не в файл а в скаляр
XML - очень большой сериализатор, но поддерживается везде и всегда
HTML == valid XML
XML::Parser - поточный парсер быстро работает и юзает хэндлеры на различные теги XML

Флаги и параметры
-e '' - параметр e со значением ''
можно опрделять входные параметры 
GetOptions();

интерактивный режим
is_interactive() - можно пообщаться с пользователем или нет?

дз сдать через 3 лекции
1) тест 1 - сложный(не обязательно проходить, но + баллы)
тест 2 - простой
2) Клиент-сервер калькулятор
каркасы есть 
протоколы определить самим. Статистика

досдача после срока - без штрафа!

в пред домашке нужна глобальная переменная
мы создадим ее из глоба

внутри пакета 4 глобальные переменные и для них 4 геттера и сеттера

полный путь в глобе указывать и ищем внутри другого пакета
