\$var - взятие ссылки

@{ $aref } - разыменование
@simpel = qw(1 2 3 bare); конструирует массив

$aref->[2] разыменование
$$aref[2] - тоже
$#$aref

$aref = \@array - неанонимный масси
$aref = [1, 2, 3] -анонимный массив

хеши - несортированные 
keys и values в одном порядке

=> - жирная запятая, чтобы не ставить линие ковычки слева
%hash = ( );
$href = { };

$, - output field separator (разделитель)

@array = (1, 2, 3); - норм массив
@array = [1, 2, 3] - одна ссылка

ЗАДАЕМ ВСЕ ЧЧЕРЕЗ КРУГЛЫЕ СКОБКИ!

Символические ссылки - можно создать с одним именем 5 разныъх переменных

hash{ str } -создаст str
hash{ +str } - посмотрит на key str
$" - сепаратор всего что в коввычках

BEGIN { ... } // копируется в конец проги
END { ... } // копируется в начало проги

}{ - бабочка - можно разделить while !!!!

фунциии
sub NAME(PROTO) BLOCK -обьявление 

$sub = sub

@_ - массив аргументов
все команды по умалчанию с @_

my $a = shift; // первый элемент
my ($a, $b) = @_; 

контексты (вывод)
скалярный 
массива
void

return unless defined wantarray // смотрим нужен ли массив
return (1, 2, 3) if wantarray
1;
возвр значение - последний  statement 

вызов 
mysub(...);
mysub ...;
старое - &mysub( );
&mysub; # == &mysbub(@_);


прототипы
sub vararg($$;$); - обязательно 2 скаляра, опционально третий
($$;@) - любое кол-во элементов


sub check () {}
check {
#проверка аргумментов
} 

grep - фильтр
map - преобразует список
sort - сортирует

eval - выполняет код в ковычках
warn - exception
die - смерть

chop - отрезает последний
chomp - $/ - отрезает то что там в конце строки

lc, lcfirst, ucfirst, uc

\L \l \U \u
изменяет в троке прям "\u\LnAmE\E"; #Name

say reverse 'dog';
#dog т к say - список

say ucfirst reverse 'dog';
# God - тк ucfirst берет скаляр и отдает скаляр

log  - по умолчанию e

keys - ключи; values - значения; each - попарно

push pop shift unshift #конец, начало
splice меняет массив как угодно

gmtime localtime time strftime

есть стек:
caller - номер фрейма
caller(0) - этот фрейм
caller(1) - кто вызвал

Оператор определяет тип операнда
1)TERM - переменная, обращение к хэш, вызов функции, do, анонимные массвиы и тд
2)-> STMT->{ ... }
3)++ и --
++$i + $i++ -неопределенное поведение
++("a9") # b0
-- так не делает
4) !
false == 0, "",  undef, остально true
True == 1; False == ""
5) - (унарный)
-bare #"-bare"
-"-word" # "+word"
~ битовая инверсия
+ (унарный)
say +( 1 + 2 ) * 3; #9
say (1 + 2) * 3; #3
6) операторы =~ !~
7) + - .
1 . 2 # 12
1.2 # 1.2
8) >> <<
9)>= <= le ge и тд
10) == != <=> eq ne cmp
"NaN" != "NaN" - не поддерживается в системе
"NaN" == "Nan" - поддерживается
"a" == "b" # 0 приводят к числам т е 0 == 0
"1a" == "1b" # 0 т к 1 == 1
11) ~~ -умное сравнение smartmatch
12) & | ^(xor)
13) && || // (defined-or)
14) операторы диапозона .. ...
@b = @a[3..7];
say "A"..."Z";
EO - маркер конца вывода sequence
... - не проверяет дальнейшее
.. - проверяет дальнейшее
15)тернарный оператор
можно присваивать!!!
16)+= -= *=
17) , =>
CONST => val 
18) низкоприоритетые and or xor not

Операторы кавычки
q; - cтрока без интерполяции; - разделители
можно любой символ или даже букву
монжно экранировать их
qq; - строка с интерполяцией;
qw(a, b, c) - генератор списка тоже любой разделитель
qx{uname -a}; - внешняя команда с интерполяцией
qr// - сборка регулярного выражения
s// y/ tr///

say <<EOD;
Content of Document
EOD

в презентации смотреть как выводить однострочник из файла

дз калькулятор eval
